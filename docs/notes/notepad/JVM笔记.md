## 类加载机制

- 装载，双亲委派
- 连接

   - 验证，保证被加载的类
   - 准备，为类的静态变量分配内存空间，并初始化默认值（只是给默认值）
   - 解析，将类中的符号转换为直接引用（String str = 地址是什么）
- 初始化，为静态变量赋值

## 运行时数据区

- 方法区：方法区只有一个，生命周期和虚拟机一样

   - 线程共享
   - 类信息、常量、静态变量、即时编译器编译之后的代码
   - 内存不够的话，会发成OutOfMemoryError
   - 1.7 老年代（存储在连续的堆空间上）
   - 1.8 元空间（使用的是本地内存）
- 堆：堆也只有一个，生命周期和虚拟机一样

   - 线程共享
   - 内存不够的话会发生OutOfMemoryError
- Java虚拟机栈

   - 一个线程创建代表一个栈，每个方法被当前线程调用了，就代表一个栈针
   - Java方法压栈，执行完毕出栈
   - 栈不够用的时候，StackOverflowError
- 本地方法栈，native修饰的
- 程序计数器

## 进程和线程

- 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

## 内存泄漏和内存溢出

- 溢出是指创建太多对象导致内存空间不足（程序在申请内存时没有足够的内存空间供其使用）
- 泄漏是无用对象没有回收（程序在申请内存后无法释放已申请的内存空间）

## JVM 怎么判断对象是无用对象

- 引用计数法，给Java对象添加一个引用计数器

每当有一个地方引用它时，计数器+1；引用失效则 -1，当计数器不为0时，判断该对象存活；否则判断为死亡（计数器 = 0），无法解决 对象间相互循环引用 的问题
- 引用链法（可达性分析法）将一系列的 GC Roots 对象作为起点，从这些起点开始向下搜索,当一个对象到 GC Roots 没有任何引用链相连时，则判断该对象不可达

```
可作为 GC Root 的对象有：
1.Java虚拟机栈（栈帧的本地变量表）中引用的对象
2.本地方法栈 中 JNI引用对象
3.方法区 中常量、类静态属性引用的对象
```

## 对象引用的几种方式
| 引用类型 | 垃圾回收时间 | 用途 | 生存时间 |
| --- | --- | --- | --- |
| 强引用 | 任何时候都不会被回收 | 对象的一般状态 | JVM停止运行时终止 |
| 弱引用 | 发生GC的时候被回收 | 对象缓存 | GC运行后终止 |
| 软引用 | 内存不足的时候被回收 | 对象缓存 | 内存不足时终止 |
| 虚引用 | 随时都可能被回收 | unKnown | unKnown |


## 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

- 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

## 上下文切换

- 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换

## 死锁

- 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
- 产生死锁必须具备以下四个条件

```
互斥条件：该资源任意一个时刻只由一个线程占用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
```

### CMS收集器和G1收集器的区别

- 
区别一： 使用范围不一样

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用

G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

- 
区别二： STW的时间

CMS收集器以最小的停顿时间为目标的收集器。

G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

- 
区别三： 垃圾碎片

CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片

G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

- 
区别四： 垃圾回收的过程不一样

| CMS收集器 | G1收集器 |
| --- | --- |
| 1. 初始标记 | 1.初始标记 |
| 2. 并发标记 | 2. 并发标记 |
| 3. 重新标记 | 3. 最终标记 |
| 4. 并发清除 | 4. 筛选回收 |


### jstack定位问题

1. jps 查询到线程id   top

2. printf("%x\n") pid #获取到16进制的进程id

3. jstack pid  |grep pid（16进制）

> jstack [options] pid >> /xxx/xx/x/dump.log

```shell
    options 参数说明
    -F
    当 jstack [-l] pid 没有响应时，强制打印一个堆栈转储。
    
    -l
    打印关于锁的其他信息，比如拥有的java.util.concurrent ownable同步器的列表。
    
    -m
    打印包含Java和本机C/ C++帧的混合模式堆栈跟踪。
    
    -h
    打印帮助信息
    
    -help
    打印帮助信息
```

