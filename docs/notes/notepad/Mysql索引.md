## 索引

### 索引是什么

- 索引是一种数据结构，可以快速检索出数据库中的数据

### 索引具体采用哪些数据结构

- Hash索引，查询单条快，不支持范围查询（Hash索引底层是哈希表，是一种类似Key—Value的存储数据的结构，所以在存储关系上没有任何关系，所以对于区间查询就要扫全表。Hash索引只适用于等值的场景）Hash所以没办法利用索引排序，不支持多列联合索引，如果有大量键值重复的话，Hash效率会很低，因为会出现hash碰撞
- B+ Tree，innodb默认，B+ Tree是多路平衡查找树，数据有序的分布在叶子节点上

### B+ Tree 的叶子节点都可以存什么

- 可以存整行数据，也可以存主键
- 聚簇索引（主键索引） 叶子节点存的是整行数据
- 非聚簇索引（非主键索引） 叶子节点存的是主键的值
- 聚族索引查询效率更快
- 所谓聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据，我们刚才看到的B+树索引就是一种聚簇索引，而非聚簇索引就是将数据和索引分开，查找时需要先查找到索引，然后通过索引回表找到相应的数据。InnoDB有且只有一个聚簇索引，而MyISAM中都是非聚簇索引。

### 聚簇索引为什么会比非聚簇索引效率高

- 聚族索引叶子节点存储的是整行数据，检索到之后可以直接拿到数据，非聚簇索引检索拿到数据之后，还需要回表，根据主键值再拿具体的数据。

### 什么情况下不用回表

- 覆盖索引，一个查询语句从索引中就可以拿到数据，不必从表中读取，当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。

### 创建联合索引要考虑什么

- 查询概率比较高，经常用做where条件的字段
- 把识别度最高的，放在前面
- 最左匹配原则

### 什么情况下索引会失效

- 联合索引时，违背最左匹配原则
- 范围查询
- Like %
- 不等于
- or
- 索引列上使用计算或函数
- 类型不匹配

### mysql 5.6对索引做了什么优化

- 索引下推
- MySQL 5.6引入了索引下推优化，默认开启，使用`SET optimizer_switch = 'index_condition_pushdown=off'`可以将其关闭。官方文档中给的例子和解释如下：people表中（zipcode，lastname，firstname）构成一个索引

`SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%'`  如果没有使用索引下推技术，则MySQL会通过`zipcode='95054'`从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于`lastname LIKE '%etrunia%`'和`address LIKE '%Main Street%'`来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合`zipcode='95054'`的索引，然后根据`lastname LIKE '%etrunia%'`和`address LIKE '%Main Street%'`来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

### 数据库事务隔离级别
| 事务隔离级别 | 脏读(是否出现) | 不可重复读 | 幻读 |
| --- | --- | --- | --- |
| 读未提交（read-uncommitted） | 是 | 是 | 是 |
| 读已提交（read-committed） | 否 | 是 | 是 |
| 可重复读（repeatable-read） | 否 | 否 | 是 |
| 串行化（serializable） | 否 | 否 | 否 |


## 执行计划 EXPLAIN

### id

- 代表优先级  id值越大，越先执行，id值相同，从上往下执行。（比如示例的这条sql的执行计划，就是先执行第一行，再执行第二行）

### select_type

表示select类型 取值如下

- simple 简单表 即不使用表连接或者子查询
- primary 包含union或者子查询的主查询 即外层的查询
- union UNION中的第二个或者后面的查询语句
- subquery 一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询
- derived 派生表 该临时表是从子查询派生出来的

等等

### type

- 表示MySQL在表中查找数据的方式，或者叫访问类型，以下对于type取值的说明 从上往下性能由最差到最好
- all:全表扫描，MySQL遍历全表来找到匹配的行
- index：索引全扫描，MySQL遍历挣个索引来查询匹配的行
- range：索引范围扫描，常见于<、<=、>、>=、between等操作符
- ref：使用非唯一索引或唯一索引的前缀扫描，返回匹配的单行数据
- eq_ref：类似ref，区别就在于使用的索引是唯一索引，简单来说，就是多表连接中使用primary key或者unique index作为关联条件。
- const/system：单表中最多有一个匹配行，查询起来非常迅速，常见于根据primary key或者唯一索引unique index进行的单表查询
- null：mysql不用访问表或者索引，直接就能够得到查询的结果，例如select 1+2 as result。

### possible_keys

- 表示查询时可能使用的索引

### key

- 表示实际使用的索引

### key_len

- 使用到索引字段的长度

### rows

- 扫描数量

### Extra

执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息，常用取值如下：

- Using index：直接访问索引就取到了数据，高性能的表现。
- Using where：直接在主键索引上过滤数据，必带where子句，而且用不上索引
- Using index condition：先条件过滤索引，再查数据，
- Using filesort：使用了外部文件排序 只要见到这个 就要优化掉
- Using temporary：创建了临时表来处理查询 只要见到这个 也要尽量优化掉

## 索引

- 索引是为了加速对表中数据进行的检索而创建的一种分散存储的数据结构
- 全值匹配我最爱,最左前缀要遵守;
- 带头大哥不能死,中间兄弟不能断;
- 索引列上少计算,范围之后全失效;
- LIKE百分写最右,覆盖索引不写星;
- 不等空值还有or,索引失效要少用;

# myisam和innodb

1. MySQL 5.5之前默认是myisam 之后是innodb
2. myisam不支持事务，表锁，允许没有任何索引和主键的表存在，保存有表的总行数coun(*),myisam的索引以表名+.MYI文件分别保存。
3. innodb支持事务，行锁，果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见),没有保存表的总行数,innodb的索引和数据一起保存在表空间里。
